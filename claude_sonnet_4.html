<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triple Pendulum Chaos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #001122, #000000);
        }

        .timestamp {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff88;
            font-size: 14px;
            opacity: 0.7;
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff88;
            font-size: 12px;
            opacity: 0.5;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div class="timestamp" id="timestamp">00:00</div>
    <div class="info">Triple Pendulum • Gravitational Physics • Trail Rendering</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const timestampEl = document.getElementById('timestamp');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Physics constants
        const g = 9.81; // gravity
        const dt = 0.016; // time step (60 FPS)

        // Pendulum parameters
        const pivot = { x: canvas.width / 2, y: canvas.height * 0.2 };
        const l1 = 150, l2 = 120, l3 = 100; // lengths
        const m1 = 20, m2 = 15, m3 = 10; // masses

        // Initial conditions (slightly chaotic)
        let θ1 = Math.PI / 2 + 0.1;
        let θ2 = Math.PI / 2 + 0.2;
        let θ3 = Math.PI / 2 + 0.15;
        let ω1 = 0, ω2 = 0, ω3 = 0; // angular velocities

        // Trail arrays
        const trail1 = [];
        const trail2 = [];
        const trail3 = [];
        const maxTrailLength = 800;

        let startTime = Date.now();

        function calculatePositions() {
            // Position of first pendulum bob
            const x1 = pivot.x + l1 * Math.sin(θ1);
            const y1 = pivot.y + l1 * Math.cos(θ1);

            // Position of second pendulum bob
            const x2 = x1 + l2 * Math.sin(θ2);
            const y2 = y1 + l2 * Math.cos(θ2);

            // Position of third pendulum bob
            const x3 = x2 + l3 * Math.sin(θ3);
            const y3 = y2 + l3 * Math.cos(θ3);

            return { x1, y1, x2, y2, x3, y3 };
        }

        function updatePhysics() {
            // Triple pendulum equations of motion (Lagrangian mechanics)
            // These are complex coupled differential equations

            const { x1, y1, x2, y2, x3, y3 } = calculatePositions();

            // Simplified but accurate physics calculations
            const c1 = Math.cos(θ1), s1 = Math.sin(θ1);
            const c2 = Math.cos(θ2), s2 = Math.sin(θ2);
            const c3 = Math.cos(θ3), s3 = Math.sin(θ3);

            const c12 = Math.cos(θ1 - θ2), s12 = Math.sin(θ1 - θ2);
            const c23 = Math.cos(θ2 - θ3), s23 = Math.sin(θ2 - θ3);
            const c13 = Math.cos(θ1 - θ3), s13 = Math.sin(θ1 - θ3);

            // Mass matrix elements
            const M11 = (m1 + m2 + m3) * l1 * l1;
            const M12 = (m2 + m3) * l1 * l2 * c12;
            const M13 = m3 * l1 * l3 * c13;
            const M22 = (m2 + m3) * l2 * l2;
            const M23 = m3 * l2 * l3 * c23;
            const M33 = m3 * l3 * l3;

            // Right-hand side (Coriolis + gravity terms)
            const R1 = -(m2 + m3) * l1 * l2 * s12 * ω2 * ω2
                - m3 * l1 * l3 * s13 * ω3 * ω3
                - (m1 + m2 + m3) * g * l1 * s1;

            const R2 = (m2 + m3) * l1 * l2 * s12 * ω1 * ω1
                - m3 * l2 * l3 * s23 * ω3 * ω3
                - (m2 + m3) * g * l2 * s2;

            const R3 = m3 * l1 * l3 * s13 * ω1 * ω1
                + m3 * l2 * l3 * s23 * ω2 * ω2
                - m3 * g * l3 * s3;

            // Solve 3x3 system for angular accelerations (simplified)
            const det = M11 * (M22 * M33 - M23 * M23)
                - M12 * (M12 * M33 - M13 * M23)
                + M13 * (M12 * M23 - M22 * M13);

            if (Math.abs(det) > 1e-10) {
                const α1 = (R1 * (M22 * M33 - M23 * M23)
                    - M12 * (R2 * M33 - R3 * M23)
                    + M13 * (R2 * M23 - R3 * M22)) / det;

                const α2 = (M11 * (R2 * M33 - R3 * M23)
                    - R1 * (M12 * M33 - M13 * M23)
                    + M13 * (M12 * R3 - R2 * M13)) / det;

                const α3 = (M11 * (M22 * R3 - M23 * R2)
                    - M12 * (M12 * R3 - M13 * R2)
                    + R1 * (M12 * M23 - M22 * M13)) / det;

                // Update velocities and positions
                ω1 += α1 * dt;
                ω2 += α2 * dt;
                ω3 += α3 * dt;

                θ1 += ω1 * dt;
                θ2 += ω2 * dt;
                θ3 += ω3 * dt;

                // Add small damping to prevent runaway
                ω1 *= 0.9995;
                ω2 *= 0.9995;
                ω3 *= 0.9995;
            }
        }

        function updateTrails() {
            const { x1, y1, x2, y2, x3, y3 } = calculatePositions();

            trail1.push({ x: x1, y: y1 });
            trail2.push({ x: x2, y: y2 });
            trail3.push({ x: x3, y: y3 });

            if (trail1.length > maxTrailLength) trail1.shift();
            if (trail2.length > maxTrailLength) trail2.shift();
            if (trail3.length > maxTrailLength) trail3.shift();
        }

        function drawTrail(trail, color, width) {
            if (trail.length < 2) return;

            for (let i = 1; i < trail.length; i++) {
                const alpha = i / trail.length;
                const lineWidth = width * alpha * alpha;

                ctx.strokeStyle = color.replace('1)', `${alpha * 0.8})`);
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
                ctx.lineTo(trail[i].x, trail[i].y);
                ctx.stroke();
            }
        }

        function draw() {
            // Fade background for trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const { x1, y1, x2, y2, x3, y3 } = calculatePositions();

            // Draw trails
            drawTrail(trail1, 'rgba(255, 100, 100, 1)', 3);
            drawTrail(trail2, 'rgba(100, 255, 100, 1)', 2.5);
            drawTrail(trail3, 'rgba(100, 100, 255, 1)', 2);

            // Draw pendulum arms
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            // First arm
            ctx.beginPath();
            ctx.moveTo(pivot.x, pivot.y);
            ctx.lineTo(x1, y1);
            ctx.stroke();

            // Second arm
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Third arm
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.stroke();

            // Draw pivot point
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(pivot.x, pivot.y, 6, 0, Math.PI * 2);
            ctx.fill();

            // Draw pendulum bobs with glow
            const drawBob = (x, y, radius, color) => {
                // Glow effect
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Solid bob
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            };

            drawBob(x1, y1, 12, '#ff6464');
            drawBob(x2, y2, 10, '#64ff64');
            drawBob(x3, y3, 8, '#6464ff');
        }

        function updateTimestamp() {
            const elapsed = (Date.now() - startTime) / 1000;
            const minutes = Math.floor(elapsed / 60);
            const seconds = Math.floor(elapsed % 60);
            timestampEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function animate() {
            updatePhysics();
            updateTrails();
            draw();
            updateTimestamp();
            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Start animation
        animate();
    </script>
</body>

</html>