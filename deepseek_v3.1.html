<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triple Pendulum Chaos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .info {
            position: absolute;
            bottom: 20px;
            text-align: center;
            width: 100%;
            opacity: 0.7;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <canvas id="pendulumCanvas"></canvas>
    <div class="info"></div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('pendulumCanvas');
        const ctx = canvas.getContext('2d');
        const width = window.innerWidth * 0.9;
        const height = window.innerHeight * 0.9;
        canvas.width = width;
        canvas.height = height;

        // Pendulum parameters
        const g = 9.81; // gravitational constant
        const trailLength = 2000; // number of points to keep in trail

        // Pendulum properties (mass, length, angle, velocity)
        const pendulums = [
            { m: 1.0, L: height / 4, theta: Math.PI / 2, omega: 0.0 },
            { m: 0.6, L: height / 5, theta: Math.PI / 2 + 0.1, omega: 0.0 },
            { m: 0.3, L: height / 6, theta: Math.PI / 2 + 0.2, omega: 0.0 }
        ];

        // Trail data storage
        const trails = [];
        for (let i = 0; i < 3; i++) {
            trails.push([]);
        }

        // Starting position (center of canvas)
        const origin = { x: width / 2, y: height / 3 };

        // Time tracking
        let lastTime = 0;
        const timeStep = 1 / 60; // fixed time step for physics

        // Colors for pendulum arms and bobs
        const colors = ['#ff5555', '#55ff55', '#5555ff'];
        const trailColors = ['#ff000040', '#00ff0040', '#0000ff40'];

        // Calculate pendulum positions
        function getPositions() {
            const positions = [];
            let x = origin.x;
            let y = origin.y;

            for (let i = 0; i < pendulums.length; i++) {
                const p = pendulums[i];
                x += p.L * Math.sin(p.theta);
                y += p.L * Math.cos(p.theta);
                positions.push({ x, y });
            }

            return positions;
        }

        // Update pendulum physics using Lagrangian mechanics
        function updatePhysics(dt) {
            // This is a simplified implementation - a real triple pendulum would
            // require solving a complex system of differential equations

            for (let i = 0; i < pendulums.length; i++) {
                const p = pendulums[i];

                // Calculate acceleration (simplified)
                let acceleration = 0;

                if (i === 0) {
                    // First pendulum - affected by gravity and connected to fixed point
                    acceleration = -g / p.L * Math.sin(p.theta);
                } else {
                    // Subsequent pendulums - affected by previous pendulum's motion
                    const prev = pendulums[i - 1];
                    acceleration = -g / p.L * Math.sin(p.theta) +
                        (prev.L / p.L) * Math.cos(p.theta - prev.theta) * prev.omega * prev.omega;
                }

                // Update angular velocity and angle
                p.omega += acceleration * dt;
                p.theta += p.omega * dt;

                // Add some damping to prevent energy buildup
                p.omega *= 0.9999;
            }
        }

        // Draw the pendulum and trails
        function draw() {
            // Clear canvas with slight transparency for trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            const positions = getPositions();

            // Draw trails
            for (let i = 0; i < trails.length; i++) {
                const trail = trails[i];
                if (trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(trail[0].x, trail[0].y);

                    for (let j = 1; j < trail.length; j++) {
                        ctx.lineTo(trail[j].x, trail[j].y);
                    }

                    ctx.strokeStyle = trailColors[i];
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Add current position to trail
                trail.push({ x: positions[i].x, y: positions[i].y });

                // Limit trail length
                if (trail.length > trailLength) {
                    trail.shift();
                }
            }

            // Draw pendulum arms and bobs
            let prevX = origin.x;
            let prevY = origin.y;

            for (let i = 0; i < pendulums.length; i++) {
                const pos = positions[i];

                // Draw arm
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = colors[i];
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw bob
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5 + pendulums[i].m * 5, 0, Math.PI * 2);
                ctx.fillStyle = colors[i];
                ctx.fill();

                prevX = pos.x;
                prevY = pos.y;
            }

            // Draw fixed point
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        }

        // Animation loop
        function animate(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Fixed time step physics update
            updatePhysics(timeStep);

            draw();
            requestAnimationFrame(animate);
        }

        // Start animation
        requestAnimationFrame(animate);

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * 0.9;
            canvas.height = window.innerHeight * 0.9;
            origin.x = canvas.width / 2;
            origin.y = canvas.height / 3;
        });
    </script>
</body>

</html>